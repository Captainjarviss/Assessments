# -*- coding: utf-8 -*-
"""LVADSUSR71_Arpit_Lab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1679HrQLC_uqJ6k3TBO4Tf2CqYsgBj4fu
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report

data=pd.read_csv("/content/sample_data/winequality-red.csv")

data.head()

data.info()



data.isnull()

data.fillna(data.median(), inplace=True)

data.info()

#now let's check for the missing values
missing_values_check = data.isnull().sum()
missing_values_check



data['quality_label'] = data['quality'].apply(lambda x: 1 if x >= 7 else 0)
data

quality_distribution = data['quality_label'].value_counts(normalize=True)
quality_distribution

Q1 = data.quantile(0.25)
Q3 = data.quantile(0.75)
IQR = Q3 - Q1
IQR

outliers = ((data < (Q1 - 1.5 * IQR)) | (data > (Q3 + 1.5 * IQR))).any(axis=1)

outlier_count = outliers.sum()
outlier_proportion = outlier_count / len(data)
outlier_count, outlier_proportion

wine_data_capped = data.copy()

for column in data.columns[:-2]:  
    lower_bound = Q1[column] - 1.5 * IQR[column]
    upper_bound = Q3[column] + 1.5 * IQR[column]
    wine_data_capped[column] = wine_data_capped[column].clip(lower=lower_bound, upper=upper_bound)

wine_data_capped.describe()

from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split


X = wine_data_capped.drop(['quality', 'quality_label'], axis=1)
y = wine_data_capped['quality_label']

smote = SMOTE(random_state=42)
X_smote, y_smote = smote.fit_resample(X, y)

X_train, X_test, y_train, y_test = train_test_split(X_smote, y_smote, test_size=0.2, random_state=42)

balance_check = y_train.value_counts(normalize=True)

balance_check

rf_classifier = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)
rf_classifier.fit(X_train, y_train)
y_pred_rf = rf_classifier.predict(X_test)
print(classification_report(y_test, y_pred_rf, target_names=['Bad', 'Good']))

